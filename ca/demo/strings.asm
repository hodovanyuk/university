%TITLE "Процедуры для работы со строками - Copyright 1989,1995 by Tom Swan"

        IDEAL

        MODEL small

        CODESEG

        PUBLIC MoveLeft, MoveRight, StrNull, StrLength
        PUBLIC StrUpper, StrCompare, StrDelete, StrInsert
        PUBLIC StrConcat, StrCopy, StrPos, StrRemove

; ------------------------------------------------------------------
; Для создания файла STRINGS.OBJ воспользуйтесь командой
; TASM STRINGS.
; Для использования процедур добавьте в вашу программу операторы
; EXTRN <procedure>:PR0C, где <procedure> является одним из
; следующих идентификаторов:
;
; MoveLeft   - переместиться в сторону возрастания индексов
; MoveRight  - переместиться в сторону убывания индексов
; StrNull    - удалить все символы из строки
; StrLength  - возвратить количество символов в строке
; StrUpper   - преобразовать символы строки в прописные
; StrCompare - сравнить две строки в алфавитном порядке
; StrDelete  - удалить символы из строки
; StrInsert  - вставить символы в строку
; StrConcat  - присоединить одну строку к другой
; StrCopy    - скопировать одну строку в другую
; StrPos     - найти в строке позицию подстроки
; StrRemove  - удалить из строки подстроку
;
; После ассемблирования вашей программы скомпонуйте ее совместно с
; STRINGS.OBJ. Например, если ваша программа называется MYPROG,
; сначала выполните ассемблирование MYPR0G в MYPR0G.0BJ и затем
; скомпонуйте ее с помощью команды TLINK MYPROG+STRINGS.
;
; СТРОКОВЫЕ ПЕРЕМЕННЫЕ:
; Строка является простым массивом символов по одному символу на
; 8-битовый байт. Последним символом строки должен быть нулевой
; символ (ASCII 0).
; Пустая строка содержит только нулевой символ.
; Строковые переменные описываются следующим образом:
; STRING DB 81 DUP (0) ; 80-символьная строка + нуль
;
; СТРОКОВЫЕ КОНСТАНТЫ:
; Оставляйте всегда один дополнительный байт для нулевого окончания.
; Символьные константы (которые могут использоваться в качестве
; переменных) должны также заканчиваться соответствующим образом.
; Например:
;
; С1 db This is a test string., 0
;
; СЕГМЕНТНЫЕ РЕГИСТРЫ.
; В подпрограммах этого пакета подразумевается, что ES и DS адресуют
; один и тот же сегмент. Установите ES=DS до вызова любой из этих
; подпрограмм.
; ------------------------------------------------------------------

ASCNull EQU 0                   ; Символ ASCII нуля

; ------------------------------------------------------------------
; MoveLeft Переместить в памяти блок байтов влево (вниз)
; ------------------------------------------------------------------
; Вход:
; SI = адрес строки источника (s1)
; DI = адрес строки назначения (s2)
; BX = индекс s1 (i1)
; DX = индекс s2 (i2)
; CX = количество перемещаемых байтов (count)
; Выход:
; count байтов из s1[i1] перемещены в позицию, начинающуюся с s2[i2]
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    MoveLeft
        jcxz @@99               ; выход, если count = 0
        push CX                 ; сохранить изменяемые регистры
        push SI
        push DI

        add SI,BX               ; индекс строки источника
        add DI,DX               ; индекс строки назначения
        cld                     ; автоувеличение SI и DI
        rep movsb               ; перемещать, пока CX <> 0

        pop DI                  ; восстановить регистры
        pop SI
        pop CX
@@99:
        ret                     ; возврат в вызывающую программу
ENDP    MoveLeft

; ------------------------------------------------------------------
; MoveRight Перемещение в памяти блока байтов вправо (вверх)
; ------------------------------------------------------------------
; Вход:
; (такой же, как в MoveLeft)
; Выход:
; (такой же, как в MoveLeft)
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    MoveRight
        jcxz @@99               ; выход, если count = 0
        push CX                 ; сохранить изменяемые регистры
        push DI
        push SI

        add SI,BX               ; индекс строки источника
        add DI,DX               ; индекс строки назначения
        add SI,CX               ; настроиться на последний байт источника
        dec SI
        add DI,CX               ; настроиться на последний байт назначения
        dec DI
        std                     ; автоуменьшение SI и DI
        rep movsb               ; перемещать, пока CX <> 0
        pop SI                  ; восстановить регистры
        pop DI
        pop CX
@@99:
        ret                     ; возврат в вызывающую программу
ENDP    MoveRight

; ------------------------------------------------------------------
; StrNull Удалить все символы в строке
; ------------------------------------------------------------------
; Вход:
; DI = адрес строки (s)
; Выход:
; s[0] <- нулевой символ (ASCII 0)
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    StrNull
        mov [byte ptr DI],ASCNull   ; вставить нуль в s[0]
        ret                         ; возврат в вызывающую программу
ENDP    StrNull

; ------------------------------------------------------------------
; StrLength Подсчитать в строке количество ненулевых символов
; ------------------------------------------------------------------
; Вход:
; DI = адрес строки (s)
; Выход:
; CX = количество ненулевых символов в s
; Регистры:
; CX
; ------------------------------------------------------------------
PROC    StrLength
        push AX                 ; сохранить изменяемые регистры
        push DI
        xor AL,AL               ; AL <- искомый символ (null)
        mov CX,0ffffh           ; CX <- максимальная глубина поиска
        cld                     ; автоувеличение DI
        repnz scasb             ; искать AL, пока [DI]<>null & CX<>0
        not CX                  ; логическое отрицание CX
        dec CX                  ; вычитание 1 дает длину строки
        pop DI                  ; восстановить регистры
        pop AX
        ret                     ; возврат в вызывающую программу
ENDP    StrLength

; ------------------------------------------------------------------
; StrUpper Преобразовать символы строки в прописные
; ------------------------------------------------------------------
; Вход:
; DI = адрес преобразуемой строки (s)
; Выход:
; строчные символы строки преобразуются в прописные
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    StrUpper
        push AX                 ; сохранить изменяемые регистры
        push CX
        push DI
        push SI
        call StrLength          ; установить CX = длина строки
        jcxz @@99               ; выход, если длина = 0
        cld                     ; автоувеличение SI, DI
        mov SI,DI               ; установить SI=DI
@@10:
        lodsb                   ; AL <- s[SI]; SI <- SI + 1
        cmp AL,'a'              ; AL >= a?
        jb @@20                 ; если нет, то продолжить поиск
        cmp AL,'z'              ; AL <= z?
        ja @@20                 ; Если нет, то продолжить поиск
        sub AL,'a'-'A'          ; преобразовать строчные символы в прописные
@@20:
        stosb                   ; s[DI] <- AL; DI <- DI + 1
        loop @@10               ; CX <- CX-1; цикл, если CX <> 0
@@99:
        pop SI                  ; восстановить регистры
        pop DI
        pop CX
        pop AX
        ret                     ; возврат в вызывающую программу
ENDP    StrUpper

; ------------------------------------------------------------------
; StrCompare Сравнить две строки
; ------------------------------------------------------------------
; Вход:
; SI = адрес строки 1 (s1)
; DI = адрес строки 2 (s2)
; Выход:
; набор флагов для условных переходов jb, jbe, je, ja, or jae.
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    StrCompare
        push AX                 ; cохранить изменяемые регистры
        push DI
        push SI
        cld                     ; автоувеличение SI
@@10:
        lodsb                   ; AL <- [SI], SI <- SI +1
        scasb                   ; сравнить AL и [DI]; DI <- DI + 1
        jne @@20                ; выход, если найдены неравные символы
        or AL,AL                ; AL=0? (т.е. конец s1)
        jne @@10                ; если нет, то переход, иначе выход
@@20:
        pop SI                  ; восстановить регистры
        pop DI
        pop AX
        ret                     ; возвратить флаги в вызывающую программу
ENDP    StrCompare

; ------------------------------------------------------------------
; StrDelete Удалить символы из строки
; ------------------------------------------------------------------
; Вход:
; DI = адрес строки (s)
; DX = индекс (i) первого удаляемого символа
; CX = количество удаляемых символов (n)
; Выход:
; в строке, начиная с позиции s[i], удалены n символов
; Замечание: предотвращает удаление конца строки
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    StrDelete
        push BX                 ; сохранить изменяемые регистры
        push CX
        push DI
        push SI

; BX = SourceIndex
; CX = Count / Len / CharsToMove
; DX = Index

        mov BX,DX               ; присвоить индекс строки BX
        add BX,CX               ; SourceIndex <- index + count
        call StrLength          ; CX <- length(s)
        cmp CX,BX               ; length > index?
        ja @@10                 ; если да, то переход на удаление символов
        add DI,DX               ; иначе вычислить индекс конца строки
        mov [byte ptr DI],ASCNull ; и вставить null
        jmp short @@99          ; переход на выход
@@10:
        mov SI,DI               ; источник = назначение
        sub CX,BX               ; CharsToMove <- Len - SourceIndex
        inc CX                  ; прибавить единицу для нулевого символа
        call MoveLeft           ; переместить символы на место удаленных
@@99:
        pop SI                  ; восстановить регистры
        pop DI
        pop CX
        pop BX
        ret                     ; возврат в вызывающую программу
ENDP    StrDelete

; ------------------------------------------------------------------
; StrInsert Вставить одну строку в другую строку
; Вход:
; SI = адрес строки 1 (s1)
; DI = адрес строки 2 (s2)
; DX = индекс вставки для s2 (i)
; Замечание: s2 должна быть достаточно большой,
;            чтобы вместить в себя (s1)!
; Выход:
; символы из строки s1 вставлены в строку s2[i]
; s1 не изменяется
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    StrInsert
        push AX                 ; сохранить изменяемые регистры
        push BX
        push CX

; AX = LenInsertion
; CX = CharsToMove

        xchg SI,DI              ; переставить SI и DI
        call StrLength          ; и найти длину s1
        xchg SI,DI              ; восстановить SI и DI
        mov AX,CX               ; сохранить length(s1) в AX

        call StrLength          ; найти длину s2
        sub CX,DX               ; CX <- length(s2) - i + 1
        inc CX                  ; CX = (CharsToMove)

; BX = индекс s1

        push DX                 ; сохранить индекс (DX) и SI
        push SI
        mov SI,DI               ; поместить в SI адрес s2
        mov BX,DX               ; установить индекс s1 в DX(i)
        add DX,AX               ; установить индекс s2 в i+LenInsertion
        call MoveRight          ; подготовить место для вставки
        pop SI                  ; восстановить индекс (DX) и SI
        pop DX

        xor BX,BX               ; установить индекс s1 (источника) в нуль
        mov CX,AX               ; установить CX в LenInsertion
        call MoveLeft           ; вставить s1 целиком в s2

        pop CX                  ; восстановить регистры
        pop BX
        pop AX
        ret                     ; возврат в вызывающую программу
ENDP    StrInsert

; ------------------------------------------------------------------
; StrConcat Объединение двух строк
; ------------------------------------------------------------------
; Вход:
; SI = адрес строки источника (s1)
; DI = адрес строки-назначения (s2)
; Замечание : s2 должна быть достаточно большой,
;             для того чтобы поместить в себе (S1)!
; Выход:
; символы строки s1 добавлены в конец s2
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    StrConcat
        push BX                 ; сохранить изменяемые регистры
        push CX
        push DX

; DX = назначение s2

        call StrLength          ; найти длину строки-назначения (s2)
        mov DX,CX               ; установить DX в индекс конца строки
        xchg SI,DI              ; переставить SI и DI
        call StrLength          ; найти длину строки-источника (s1)
        inc CX                  ; учесть нулевое окончание
        xchg SI,DI              ; восстановить SI и DI
        xor BX,BX               ; индекс источника = О
        call MoveLeft           ; скопировать строку-источник в назначение

        pop DX                  ; восстановить регистры
        pop CX
        pop BX
        ret                     ; возврат в вызывающую программу
ENDP    StrConcat

; ------------------------------------------------------------------
; StrCopy Скопировать одну строку в другую
; Вход:
; SI = адрес строки-источника (s1)
; DI = адрес строки-назначения (s2)
; Выход:
; Символы из s1 скопированы в s2
; Замечание: s2 должна по меньшей мере иметь длину Length(s1)+1
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    StrCopy
        push BX                 ; сохранить изменяемые регистры
        push CX
        push DX

        xchg SI,DI              ; переставить SI и DI
        call StrLength          ; найти длину строки-источника (s1)
        inc CX                  ; добавлением единицы учесть нулевое окончание
        xchg SI,DI              ; восстановить SI и DI
        xor BX,BX               ; индекс строки-источника = 0
        xor DX,DX               ; индекс строки-назначения = 0
        call MoveLeft           ; копировать источник в назначение

        pop DX                  ; восстановить регистры
        pop CX
        pop BX
        ret                     ; возврат в вызывающую программу
ENDP    StrCopy

; ------------------------------------------------------------------
; StrPos Найти вхождение в строку подстроки
; ------------------------------------------------------------------
; Вход:
; SI = адрес искомой подстроки
; DI = адрес проверяемой целевой строки
; Выход:
; если zf = 1, тогда DX = индекс подстроки
; если zf = 0, тогда подстрока не найдена
; Замечание: если zf = 0, то значение в DX не имеет никакого смысла
; Регистры:
; DX
; ------------------------------------------------------------------
PROC    StrPos
        push AX                 ; сохранить изменяемые регистры
        push BX
        push CX
        push DI

        call StrLength          ; найти длину целевой строки
        mov AX,CX               ; сохранить length(s2) в AX
        xchg SI,DI              ; переставить SI и DI
        call StrLength          ; найти длину подстроки
        mov BX,CX               ; сохранить length(s1) в BX
        xchg SI,DI              ; восстановить SI и DI
        sub AX,BX               ; AX = последний возможный индекс
        jb @@20                 ; выход, если длина строки < длины искомой подстроки
        mov DX,0ffffh           ; инициализировать DX в -1
@@10:
        inc DX                  ; от i = 0 до последнего возможного индекса
        mov CL,[byte BX + DI]   ; сохранить символ s[BX] в CL
        mov [byte BX + DI],ASCNull ; заменить символ нулем
        call StrCompare         ; сравнить SI с измененным DI
        mov [byte BX + DI],CL   ; восстановить замененный символ
        je @@20                 ; перейти, если найдено совпадение, DX=index, zf=1
        inc DI                  ; иначе увеличить индекс целевой строки
        cmp DX,AX               ; в случае равенства все позиции проверены
        jne @@10                ; продолжать поиск
        xor CX,CX               ; подстрока не найдена. Установить zf=0,
        inc CX                  ; чтобы показать отсутствие совпадений
@@20:
        pop DI                  ; восстановить регистры
        pop CX
        pop BX
        pop AX
        ret                     ; возврат в вызывающую программу
ENDP    StrPos

; ------------------------------------------------------------------
; StrRemove Удалить из строки подстроку
; Вход:
; SI = адрес удаляемой подстроки
; DI = адрес строки, из которой удаляется подстрока
; Выход:
; если zf = 1, тогда подстрока удалена
; если zf = 0, тогда подстрока не найдена
; Замечание: строка в SI не изменяется
; Замечание: если zf = 0, тогда строка в DI не изменяется
; Регистры:
; не используются
; ------------------------------------------------------------------
PROC    StrRemove
        push CX                 ; сохранить изменяемые регистры
        push DX

        call StrPos             ; найти подстроку, установив DX = индекс
        jne @@99                ; выход, если подстрока не найдена
        pushf                   ; сохранить флаг zf
        xchg SI,DI              ; переставить SI и DI
        call StrLength          ; найти длину подстроки
        xchg SI,DI              ; восстановить SI и DI
        call StrDelete          ; удалить CX символов из DI[DX]
        popf                    ; восстановить флаг zf
@@99:
        pop DX                  ; восстановить регистры
        pop CX
        ret                     ; возврат в вызывающую программу
ENDP    StrRemove

        END                     ; конец модуля STRINGS.ASM
