
Упражнение 5.1.
   Программа может осуществлять вызов fork несколько раз.
   Аналогично каждый дочерний процесс может вызывать fork,
   порождая своих потомков. Чтобы доказать это, напишите
   программу, которая создает два подпроцесса, а они, в
   свою очередь, - свой подпроцесс. После каждого вызова
   fork каждый родительский процесс должен использовать
   функцию printf для вывода идентификаторов своих дочерних
   процессов.

Упражнение 5.2.
   В каком случае нужно использовать вызов execv вместо execl?

Упражнение 5.3.
   Предположим, что вызовы execvp и execlp не существуют. Напишите
   эквиваленты этих процедур, используя вызовы execl и execv.
   Параметры этих процедур должны состоять из списка каталогов и
   набора аргументов командной строки.

Упражнение 5.4.
   Напишите программу waitcmd, которая выполняет произволъную
   команду при изменении файла. Она должна принимать в качестве
   аргументов командной строки имя контролируемого файла и
   команду, которая должна выполняться в случае его изменения.
   Для слежения за файлом можно использовать вызовы stat и fstat.
   Программа не должна расходовать напрасно системные ресурсы,
   поэтому следует использовать процедуру sleep (представленную
   в упражнении 2.16), для приостановки выполнения программы
   waitcmd в течение заданного интервала времени, после того
   как она проверит файл. Как должна действовать программа,
   если файл изначально не существует?

Упражнение 5.5.
   Напишите программу, показывающую, что значения переменных
   программы в родительском и дочернем процессах первоначально
   совпадают, но не зависят друг от друга.

Упражнение 5.6.
   Определите, что происходит в родительском процессе, если
   дочерний процесс закрывает файл, дескриптор которого он
   унаследовал после ветвления. Другими словами, останется ли
   файл открытым в родительском процессе или же будет закрыт?

Упражнение 5.7.
   Статус завершения программы можно получить в командном
   интерпретаторе при помощи переменной $?, например:
   $ls nonesuch
      nonesuch: No such file or directory
   $ echo $?
      2
   Напишите программу fake, которая использует целочисленное
   значение первого аргумента в качестве статуса завершения.
   Используя намеченный выше метод, выполните программу fake,
   задавая различные значения аргументов, включая большие и
   отрицательные. Есть ли польза от программы fake?

Упражнение 5.8.
   Переделайте процедуру docommand так, чтобы она возвращала
   статус вызова exit выполняемой команды. Что должно происходить,
   если вызов wait возвращает значение -1?

Упражнение 5.9.
   Включите в программу smalsh механизм для выключения с помощью
   символа \ (escaping) специального значения символов, таких как
   точка с запятой и символ &, так чтобы они могли входить в
   список аргументов программы. Программа должна также корректно
   интерпретировать комментарии, обозначаемые символом # в начале.
   Что должно произойти с приглашением командной строки, если
   пользователь выключил таким способом специальное значение
   символа возврата строки?

Упражнение 5.10.
   Процедуру fcntl можно использовать для получения копии
   дескриптора открытого файла. В этом случае он вызывается
   следующим образом:

   newfdes = fcntl( filedes,F_DUPFD,reqvalue);

   где filedes - это исходный дескриптор открытого файла.
   Постоянная F_DUPFD определена в системном заголовочном файле
   <fcntl.h>. Значение переменной reqvalue должно быть небольшим
   целым числом. После успешного вызова переменная newfdes будет
   содержать дескриптор файла, который ссылается на тот же самый
   файл, что и дескриптор filedes, и имеет то же численное значение,
   что и переменная reqvalue (если reqvalue еще не является
   дескриптором файла). Следующий фрагмент программы показывает,
   как перенаправить стандартный ввод, то есть дескриптор файла
   со значением 0:

   fd1 = open( "somefile",O_RDONLY );
   close( 0 );
   fd2 = fcntl( fd1,F_DUPFD,0 );

   После этого вызова значение дескриптора fd2 будет равно 0.
   Используя этот вызов вместе с системными вызовами open и close,
   переделайте программу smallsh так, чтобы она поддерживала
   перенаправление стандартного ввода и стандартного вывода,
   используя ту же систему обозначений, что и стандартный
   командный интерпретатор UNIX. Помните, что стандартный ввод и
   вывод соответствует дескрипторам 0 и 1 соответственно. Обратите
   внимание, что копирование дескрипторов файлов можно также
   осуществить при помощи системного вызова dup2. (Существует
   также близкий по смыслу вызов dup.)

Упражнение 5.11.
   Переделайте процедуру gentemp так, чтобы она принимала
   в качестве аргумента префикс имени временного файла.

Упражнение 5.12.
   Добавьте к командному интерпретатору smallsh команду cd.

Упражнение 5.13.
   Напишите собственную версию функции getenv.

Упражнение 5.14.
   Напишите процедуру, которая получает истинные идентификаторы
   пользователя и группы вызывающего процесса, а затем преобразует
   их в символьную форму и записывает в лог-файл.
