; Пример 13.1. Преобразование двоичного числа в 16-ричную символьную форму

text    segment                 ; начало сегмента команд
assume  CS:text,DS:data

begin:  mov AX,data             ; инициализация сегментного
        mov DS,AX               ;    регистра DS

        mov AX,16385            ;(1) преобразуемое число
        mov SI,offset string    ;(2) адрес результата
        call wrd_asc            ;(3) вызов подпрограммы wrd_asc

        mov AH,09h              ;(4) функция вывода на экран
        mov DX,offset string    ;(5)
        int 21h                 ;(6) вызов DOS

; завершим программу
        mov AX,4C00h
        int 21h

; подпрограмма преобразования слова
; при вызове преобразуемое число в АХ,
; DS:SI = адрес поля для результата
wrd_asc proc                    ;(7) начало процедуры
        push AX                 ;(8) сохраним исходное число в стеке
        and AX,0F000h           ;(9) выделим четверку битов
        mov CL,12               ;(10) сдвинем ее на 12 бит
        shr AX,CL               ;(11)    в начало AL
        call bin_asc            ;(12) преобразуем в символ ASCII
        mov byte ptr [SI],AL    ;(13) отправим в строку результата
        pop AX                  ;(14) вернем исходное число
        push AX                 ;(15) и сохраним его снова
        and AX,0F00h            ;(16) выделим четверку битов
        mov CL,8                ;(17) сдвинем ее на 8 бит
        shr AX,CL               ;(18)    в начало AL
        inc SI                  ;(19) сдвинемся по строке результата
        call bin_asc            ;(20) преобразуем в символ ASCII
        mov byte ptr [SI],AL    ;(21) отправим в строку результата
        pop AX                  ;(22) вернем исходное число
        push AX                 ;(23) и сохраним его снова
        and AX,0F0h             ;(24) выделим четверку битов
        mov CL,4                ;(25) сдвинем ее на 4 бита
        shr AX,CL               ;(26)    в начало AL
        inc SI                  ;(27) сдвинемся по строке результата
        call bin_asc            ;(28) преобразуем в символ ASCII
        mov byte ptr [SI],AL    ;(29) отправим в строку результата
        pop AX                  ;(30) вернем исходное число
        push AX                 ;(31) и сохраним его снова
        and AX,0Fh              ;(32) выделим четверку битов
        inc SI                  ;(33) сдвинемся по строке результата
        call bin_asc            ;(34) преобразуем в символ ASCII
        mov	byte ptr [SI],AL    ;(35) отправим в строку результата
        pop AX                  ;(36) восстановим АХ и стек
        ret                     ;(37) возврат в вызывающую процедуру
wrd_asc endp                    ;(38) конец процедуры

; подпрограмма преобразования 16-ричной цифры
; преобразуемая четверка битов в младшей половине AL,
; результат в AL
bin_asc proc                    ;(39) начало процедуры
        cmp	AL,9                ;(40) цифра > 9
        ja lettr                ;(41) да, на преобразование в букву
        add	AL,30h              ;(42) нет, преобразуем в символ 0..9
        jmp ok                  ;(43) и на выход из подпрограммы
lettr:  add AL,37h              ;(44) преобразуем в символ A..F
ok:     ret                     ;(45) возврат в вызывающую процедуру
bin_asc endp                    ;(46) конец процедуры

text    ends                    ; конец сегмента команд

data    segment                 ; начало сегмента данных
string  db 4 dup ('?'),'h$'     ;(47)
data    ends                    ;(22) конец сегмента данных

stk     segment stack           ;(23) начало сегмента стека
        db 256 dup (0)          ;(24) стек
stk     ends                    ;(25) конец сегмента стека

end begin                       ;(26) конец текста программы
