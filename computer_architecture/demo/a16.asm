
; CX
; джерело (звідки)    DS:SI (source index)
; призначення (куди)  ES:DI (destination index)

; direction flag (df)
; df = 0 -> right; df = 1 -> left

; movs movsb movsw
; cmps cmpsb cmpsw
; scas
; lods
; stos

; --------------------------------------------------------------------------
; А.Пересылка (копирование) строки байтов

; в сегменте данных
src     db 10,20,30,40,50       ; строка-источник
dest    db 5 dup (?)            ; строка-приемник

; в сегменте команд
        mov AX,data             ; обычная инициализация
        mov DS,AX               ; регистра DS
        mov SI,offset src       ; DS:SI = src
        push DS                 ; DS в стек
        pop ES                  ; из стека в ES, теперь ES=DS
        mov DI,offset dest      ; ES:DI = dest
        cld                     ; DF=0, движение по строке вперед
        mov CX,5                ; число пересылаемых байтов
        rep movsb               ; собственно пересылка

; --------------------------------------------------------------------------
; Б.Сравнение двух строк

; в сегменте данных
src     db 'MYFILEO1.~АТ'       ; сравниваемая строка
fname   db 'MYFILE01.DAT'       ; эталон

; в сегменте команд
        mov АХ,data
        mov DS,AX
        mov SI,offset src       ; DS:SI = src
        push DS
        pop ES
        mov DI,offset fname     ; ES:DI = fname
        cld                     ; DF = 0
        mov CX,12               ; max = 12 symbols (bytes)
        repe cmpsb              ; repeat until equal
        jne no                  ; jne = jump if not equal
yes:    ...                     ; команди, якщо рядки рівні
no:     ...                     ; команди, якщо зустрілись неоднакові символи

; --------------------------------------------------------------------------
; В.Сканирование строки

; в сегменте данных, адресуемых через ES
tail    db '       /S:3'

; в сегменте команд
        mov DI,offset tail      ; ES:DI = offset of string
        cld
        mov AL,' '              ; искомый символ - пробел
        mov CX,80               ; максимальная длина данной строки
        rере scasb              ; сканирование байтов, пока равно
        je blank                ; если в строке одни пробелы
gotit:  ...                     ; символ найден, DI=tail+5
blank:  ...

; в сегменте данных, адресуемом через ES
words   dw 10,100,234,183,16789,0,15644,...

; в сегменте команд
        mov DI,offset words     ; ES:DI -> words
        cld                     ; сканирование вперед
        mov AX,0                ; искомое число
        mov CX,1000             ; количество слов в массиве
        repne scasw             ; сканирование слов, пока не равно
        jne zeros               ; если в массиве нет нулей
gotit:  ...                     ; первый 0 найден, DI=words+12
zeros:  ...                     ; нулів не знайдено

; --------------------------------------------------------------------------
; Г.Загрузка регистра из строки

; в сегменте данных, адресуемом через DS
limits  db 90h,81h              ; анализируемые числа

; в сегменте команд
        mov SI,offset limits    ; DS:SI -> limits
        cld                     ; сканирование вперед
        lodsb                   ; AL=90h, DS:SI —> limits+l
        cmp AL,85h              ; анализ первого байта, AL=90h
        jb less85h              ; переход, если меньше 85h (у нас не меньше)
        lodsb                   ; загрузка второго байта, AL=81h
        cmp AL,82h              ; анализ второго байта
        ja over82h              ; переход, если больше 82h (у нас не больше)
range:  ...                     ; нормальное выполнение (наш случай):
                                ; 1-й байт >= 85h, 2-й байт <= 82h
less85h: ...                    ; 1-й байт не годится
over82h: ...                    ; 2-й байт не годится

; --------------------------------------------------------------------------
; Д.Запись из регистра элемента строки

; в сегменте данных, адресуемом через ES
array   dw 1024 dup (?)

; в сегменте команд
        mov DI,offset array     ; ES:DI -> array
        cld                     ; сканирование вперед
        mov AX,0                ; заполнитель массива
        mov CX,1024             ; коэффициент повторения
        rep stosw               ; заполнение всего массива нулями

; --------------------------------------------------------------------------
; Пример 16.1. Ввод пароля и сравнение символьных строк

; выведем запрос prompt с помощью функции DOS 09h
        ...

; введем пароль
        mov BX,0                ;(1) инициализируем индексный регистр
pass:   mov AH,08h              ;(2) функция ввода без эха
        int 21h                 ;(3) вызов DOS
        cmp AL,13               ;(4) Enter?
        je compr                ;(5) да, на сравнение
        mov string[BX],AL       ;(6) нет, сохраним символ
        inc BX                  ;(7) инкремент индекса
        jmp pass                ;(8) повторять до Enter

; будем сравнивать строки
compr:  push DS                 ;(9) настроим ES на наш
        pop ES                  ;(10) сегмент данных
        mov SI,offset inpt      ;(11) смещение строки ввода
        mov DI,offset pass      ;(12) смещение строки с паролем
        cld                     ;(13) направление вперед
        mov CX,BX               ;(14) инициализируем счетчик цикла
        rере cmpsb              ;(15) сравнение
        jne err                 ;(16) строки не равны
        ...                     ; продолжение программы
err:    mov AX,4C00h            ;(17) завершение программы
        int 21h                 ;(18) и выход в DOS

; поля данных
pass    db 'LuckyStrike'        ;(19) ожидаемый пароль
inpt    db 80 dup (?)           ;(20) поле для ввода пароля
prompt  db 'Введите пароль>>$'  ;(21) запрос
